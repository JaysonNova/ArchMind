import { dbClient } from '../client'

export interface VectorMapping {
  id: string;
  chunkId: string;
  similarity: number;
}

export class VectorDAO {
  // 添加向量到文档块
  static async addVector (chunkId: string, embedding: number[]): Promise<string> {
    // PostgreSQL 的 pgvector 扩展直接在 document_chunks 表中存储向量
    // 这里更新文档块的向量字段
    const sql = `
      UPDATE document_chunks
      SET embedding = $1::vector
      WHERE id = $2
      RETURNING id
    `

    const result = await dbClient.query<{ id: string }>(sql, [
      JSON.stringify(embedding),
      chunkId
    ])

    return result.rows[0].id
  }

  // 批量添加向量
  static async addVectors (chunks: Array<{ chunkId: string; embedding: number[] }>): Promise<string[]> {
    if (chunks.length === 0) { return [] }

    const ids: string[] = []
    let paramIndex = 1
    const sqlParts: string[] = []
    const values: any[] = []

    for (const chunk of chunks) {
      sqlParts.push(`($${paramIndex}::vector, $${paramIndex + 1})`)
      values.push(JSON.stringify(chunk.embedding), chunk.chunkId)
      paramIndex += 2
      ids.push(chunk.chunkId)
    }

    const sql = `
      UPDATE document_chunks AS dc
      SET embedding = v.embedding
      FROM (VALUES ${sqlParts.join(', ')}) AS v(embedding, chunk_id)
      WHERE dc.id = v.chunk_id::uuid
      RETURNING dc.id
    `

    const result = await dbClient.query<{ id: string }>(sql, values)

    return result.rows.map(row => row.id)
  }

  // 向量相似度搜索
  static async similaritySearch (
    queryEmbedding: number[],
    limit: number = 5,
    threshold: number = 0.7
  ): Promise<Array<{ chunkId: string; score: number }>> {
    // PostgreSQL pgvector 的余弦相似度操作符是 <-> (越小越相似)
    // 相似度 = 1 - 距离
    const sql = `
      SELECT
        id as chunk_id,
        1 - (embedding <-> $1::vector) as similarity
      FROM document_chunks
      WHERE embedding IS NOT NULL
        AND (1 - (embedding <-> $1::vector)) >= $2
      ORDER BY similarity DESC
      LIMIT $3
    `

    const result = await dbClient.query<{ chunk_id: string; similarity: number }>(sql, [
      JSON.stringify(queryEmbedding),
      threshold,
      limit
    ])

    return result.rows.map(row => ({
      chunkId: row.chunk_id,
      score: row.similarity
    }))
  }

  // 删除文档的所有向量（设置为 NULL）
  static async deleteByChunkIds (chunkIds: string[]): Promise<number> {
    if (chunkIds.length === 0) { return 0 }

    const placeholders = chunkIds.map((_, i) => `$${i + 1}`).join(', ')
    const sql = `
      UPDATE document_chunks
      SET embedding = NULL
      WHERE id IN (${placeholders})
    `

    const result = await dbClient.query(sql, chunkIds)

    return result.rowCount || 0
  }

  // 统计已向量化的块数量
  static async count (): Promise<number> {
    const sql = 'SELECT COUNT(*) as count FROM document_chunks WHERE embedding IS NOT NULL'
    const result = await dbClient.query<{ count: string }>(sql)
    return parseInt(result.rows[0].count, 10)
  }
}
